package jianZhiOffer.num15_NumberOf1;

/**
 * 剑指offer面试题15--二进制中1的个数
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 *
 * 容易想到的思路：该数的各位不断和1相与，然后将该数右移1位，直到所有位都比较过。
 * int类型的数（32位）只需判断32次。
 */
public class NumberOf1 {
    //1.右移版本
    // 注意：当传入负数的时候，由于>>是带符号的右移，对于负数来说高位会以1补位，n永远也不会等于9，因此会出现无限循环。
    //因此，用>>>表示，不论正负数，统统高位以0补位。
    public int numberOf1(int n) {
        int count = 0;
        while (n!=0){
            if ((n & 1)==1){
                count++;
            }
            n=n>>>1;
        }
        return count;
    }
    //2.左移版本
    public int numberOf2(int n) {
        int count = 0;
        int flag = 1;
        //当int i=1左移32次后就变为了0，此时已经检测了所有位置（32位），可以跳出循环。
        while (flag!=0){
            if ((n & flag)!=0){
                count++;
            }
            // 每次改变的只是这个变量，输入的数始终没有被改变过
            flag = flag << 1;
        }
        return count;
    }
    //3.更为巧妙的方法
    //要想出这样的方法，需要经过一定的分析。将任意数减去1,，有两种情况:
    //该数二进制表示的最低位就是1，比如数7，二进制表示为111，此时直接减去1即可；
    //最低位不为1，假设从右往左出现的第一个1，位置为m。则该数减去1后，位置m处的1会变成0，m之后所有的0都会变成1。比如数12，二进制表示为1100，减去1，先找到从右往左数的第一个1，这个位置的1变成0，其后的两个0变成1，即变成了1011。此时，如果将减去1后得到的1011和原来的1100相与，得到1000，相当于是将最右边的那个1变成了0。
    //也就是说：把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于将原整数的二进制表示中最右边的1变成0。
    public int numberOf3(int n) {
        int count = 0;
        // 只要数不为0，其二进制表示中至少含有一个1
        while (n != 0) {
            // 把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于将原整数的二进制表示中最右边的1变成0
            n = (n-1) & n;
            // 每将一个1变成了0，就计数一次
            count++;
        }
        return count;
    }

    //写一个函数判断一个整数是不是2的正整数次方。
    //一个整数如果是2的正整数次方，那么这个数必然大于0的，且它的二进制表示中有且只有一位1。所以下面一句就能判断。
    public boolean isExponOf2(int n) {
        return (numberOf3(n)==1);
    }

    //输入两个整数m和n，计算需要改变m的二进制表示中的几位才能得到n。比如10的二进制是1010，13的二进制是1101，则需要改变3次。
    //先对这两个数求异或，两个数的二进制表示中不同的位就会得到1，相同的位得到0。
    // 我们要改变的正是两个数中不同的位，因此，统计异或后二进制中1个个数，即是需要改变的位数。
    public int bitNumNeedsToBeChanged(int m, int n) {
        return numberOf1(m ^ n);
    }

}
